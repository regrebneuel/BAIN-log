---
title: "EXKURS: Reconciliation and Templating"
author: "Gaby Leuenberger"
date: 2020-11-25
---
# GREL kann viel ...
... und in phonetischer Anlehnung ans Franz√∂sische [gr√™le](https://dict.leo.org/franz%C3%B6sisch-deutsch/Hagel) kann einem die Sprache auch geh√∂rig die Laune verhageln. Daran ist sie aber nicht allein schuld; die unverhoffte Zusatzaufgabe hob die Stimmung auch nicht gerade.

Wenn man sich dann aber dran setzt, und sich nach der eigentlich einfachen Reconciliation-√úbung mit dem [lobid-gnd](https://blog.lobid.org/2018/08/27/openrefine.html)-Blog [^1] anschickt, das jetzt auch noch eins Template einzubauen, dann vermisst man schmerzlich ein vern√ºnftiges Debugging-Feature.

[^1]: Davon abgesehen, dass die GND nur ein Drittel der Autoren findet, was dann am Wert der Anreicherung zweifeln l√§sst. Eine gute √úbung und Erfahrung, dass das eben auch nicht nur das Gelbe vom Ei ist, war es allemal.

Und wehe der armen Seele, die zu fr√ºh Export klickt, ohne das Row-Template kopiert zu haben; sie tippt die m√ºhsam erarbeiteten forNonBlank-Konstrukte (auch vermisst sie die Type-Completion ihrer Python-IDE ... ü§¨).
Wenigstens ein Workaround f√ºr die fehlende Hilfe im Templating kam mir noch in den Sinn: flugs in einem zweiten Tab eine zweite OpenRefine-Instanz starten und dort in der gew√ºnschten Spalte `Edit cells > Transform...`, und schon hat man parallel Zugriff auf die Hilfe.


F√ºr das 100er-Feld war es ja noch einfach, f√ºr die Unterfelder Geburtsjahr und GND-Nummer die `forNonBlank`-Funktion einzubauen, damit bei den vielen Leeren Zellen nicht tausend leere Elemente gebaut werden.

{% raw %}
```
<datafield tag="100" ind1="0" ind2=" ">
    <subfield code="a">{{cells['Authors'].value.split('|')[0].escape('xml')}}</subfield>
    {{
    forNonBlank(
    cells['GND-Nummer'].value,
    v,
    '<subfield code="0">' + v.escape('xml') + '</subfield>', ''
    )
    }}
    {{
    	forNonBlank(
        cells['Geburtsdatum'].value,
        v,
        '<subfield code="d">' + v.escape('xml') + '</subfield>', ''
    )
    }}
</datafield>

```
{% endraw %}

F√ºr das 700er-Feld, das ja selber wieder √ºber eine `forEach`-Schleife bef√ºllt wird; war in n√ºtzlicher Frist keine lauff√§hige Version hinzubekommen. Ich vermute, der Haken liegt darin, dass die Funktion innerhalb des Strings zu liegen kommt, aber auch Backticks, wie sie in Strings f√ºr JavaScript verwendet werden k√∂nnen, fruchteten hier nix.

{% raw %}
```
{{
forEach(cells['Authors'].value.split('|').slice(1), v ,'
<datafield tag="700" ind1="0" ind2=" ">
    <subfield code="a">' + v.escape('xml') + '</subfield>
</datafield>')
}}
```
{% endraw  %}

So viel Einsatz muss f√ºr dieses Intermezzo gen√ºgen; bin ja dann gespannt auf die L√∂sung f√ºr das 700er-Feld.
